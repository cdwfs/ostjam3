Play
════════════════════════════════════════════════════════════════════════

const GROUND_Y = SCREEN_SIZE.y-16
//const EXPLOSION_DURATION = 90
const EXPLOSION_MAX_RADIUS = 24
const PORTAL_RADIUS = 16
const WARP_DURATION = 45
const CURSOR_SPEED = 2.5
const WARP_CONNECTION_COLOR_BREATHE_FRAMES = 120
const WARP_CONNECTION_OFFSET_BREATHE_FRAMES = 70
const WARP_CONNECTION_MAX_OPACITY = 0.4
const PORTAL_LIFETIME_FRAMES = 1800
const PORTAL_DRIFT_WAIT_INITIAL_MAX_FRAMES = 350
const PORTAL_DRIFT_WAIT_INITIAL_MIN_FRAMES = 150
const PORTAL_DRIFT_WAIT_MIN_FRAMES = 100
const PORTAL_DRIFT_WAIT_MAX_FRAMES = 200
const PORTAL_ANGLE_DRIFT_SPEED_MAX = 0.004 * π
const PORTAL_ANGLE_DRIFT_SPEED_MIN = 0.003 * π
const BUILDING_PUSH_RADIUS_INNER = 16
const BUILDING_PUSH_RADIUS_OUTER = 48
const BUILDING_PUSH_AMOUNT = 0.2
const PORTAL_PUSH_RADIUS_ADDITION_OUTER = 32
const PORTAL_PUSH_AMOUNT = 0.15

const SND_MISSILE_EXPLODE = {sound:explosion_sound, volume: 100%}
const SND_MISSILE_ENTER_PORTAL = {sound:warp_enter_sound, volume: 25%}
const SND_MISSILE_WARP = {sound:warp_sound, volume: 25%}
const SND_MISSILE_EXIT_PORTAL = {sound:warp_exit_sound, volume: 25%}
const SND_PORTAL_PLACE1 = {sound:portal1_sound, volume: 100%}
const SND_PORTAL_PLACE2 = {sound:portal2_sound, volume: 100%}

def enter_gameover_mode(data):
    set_mode(GameOver) because "All buildings are destroyed"

def make_building(pos):
  return make_entity({
        pos: pos,
        z: 1,
        name: "Building",
        shape: "rect",
        sprite: prototype_blocks_sprite[3][0],
    })
def itor_building_destroy(building):
    if building.destroyed:
        return iterate.REMOVE
    
def make_explosion(pos):
    play_sound({pitch: random(75%, 125%),
        pan: lerp(-100%, 100%, pos.x, 0, SCREEN_SIZE.x),
        ...SND_MISSILE_EXPLODE})
    return make_entity({
        pos: pos,
        size: xy(0,0),
        radius: 0,
        z: 2,
        shape: "disk",
        name:"Explosion",
        start_f: mode_frames,
        end_f: mode_frames+EXPLOSION_DURATION,
    })
def itor_explosion_draw(e):
    draw_disk({pos:e.pos, radius:e.radius, color:#c84, outline:#f80, z:e.z})
def itor_explosion_update(e):
    const t = (mode_frames - e.start_f) / (e.end_f - e.start_f)
    if t ≥ 1.0:
        return iterate.REMOVE
    e.radius = EXPLOSION_MAX_RADIUS * t
    e.size = xy(2*e.radius, 2*e.radius)

    
def make_missile():
    const target_building = random_value(buildings)
    if target_building == ∅:
        return // no buildings left to shoot at
    // spawn far enough off-screen to ensure w don't spawn inside a portal or explosion
    const missile_pos = xy(random_integer(0, SCREEN_SIZE.x-1), -max(EXPLOSION_MAX_RADIUS, PORTAL_RADIUS))
    const missile_dir = direction(target_building.pos - missile_pos)
    return make_entity({
        pos: missile_pos,
        z:2,
        size: xy(3,3),
        shape: "rect",
        dir: missile_dir,
        trail_start_pos: missile_pos,
        trail_lines: [],
        portal: ∅,
        portal_enter_f: -1,
        warp_sound: ∅,
    })
def itor_missile_draw(m):
    // draw missile
    if m.portal ≠ ∅: // ghost missile, mid-warp
        const src_pos = m.portal.pos
        const dst_pos = m.portal.buddy.pos
        const ghost_pos = lerp(src_pos, dst_pos, mode_frames, m.portal_enter_f, m.portal_enter_f+WARP_DURATION)
        draw_rect({pos:ghost_pos, size:m.size, color:#88f, z:m.z})
    else: // normal missile
        draw_rect({pos:m.pos, size:m.size, color:#f00, z:m.z})
    // draw trail
    if not m.is_in_portal:
        draw_line({A:m.pos, B:m.trail_start_pos, z:0, color:#800})
    for line in m.trail_lines:
        draw_line({A:line.A, B:line.B, z:0, color:#800})
    
def itor_missile_update(missile):
    // handle exiting the portal
    if missile.portal ≠ ∅:
        const start_pan = lerp(-100%, 100%, missile.pos.x, 0, SCREEN_SIZE.x)
        const end_pan = lerp(-100%, 100%, missile.portal.buddy.pos.x, 0, SCREEN_SIZE.x)
        set_pan(missile.warp_sound, lerp(start_pan, end_pan, mode_frames,
            missile.portal_enter_f, missile.portal_enter_f+WARP_DURATION))
        if mode_frames - missile.portal_enter_f ≥ WARP_DURATION:
            missile.dir = angle_to_xy( missile.portal.buddy.anchorTheta )
            missile.pos = missile.portal.buddy.pos + (missile.portal.buddy.radius+1) * missile.dir
            missile.trail_start_pos = clone(missile.pos)
            missile.portal = ∅
            missile.portal_enter_f = -1
            missile.warp_sound = ∅
            play_sound({pitch: random(75%, 125%),
                pan: lerp(-100%, 100%, missile.pos.x, 0, SCREEN_SIZE.x),
                ...SND_MISSILE_EXIT_PORTAL})
        else:
            return iterate.CONTINUE // no further processing for missiles mid-warp
    
    missile.pos += MISSILE_SPEED * missile.dir
    // collide with portals
    for portal in portals:
        if overlaps(missile.pos, portal):
            push(missile.trail_lines, {A:clone(missile.trail_start_pos), B:clone(missile.pos)})
            missile.portal = portal
            missile.portal_enter_f = mode_frames
            play_sound({pitch: random(75%, 125%),
                pan: lerp(-100%, 100%, missile.pos.x, 0, SCREEN_SIZE.x),
                ...SND_MISSILE_ENTER_PORTAL})
            missile.warp_sound = play_sound({pitch: random(75%, 125%),
                pan: lerp(-100%, 100%, missile.pos.x, 0, SCREEN_SIZE.x),
                ...SND_MISSILE_WARP})
            return iterate.CONTINUE // skip remaining checks when entering a portal        

    // collide with explosions
    if not missile.is_in_portal:
        let hit_explosion = false
        for explosion in explosions:
            if overlaps(missile, explosion, false):
                hit_explosion = true
                break
        if hit_explosion:
            push(explosions, make_explosion(missile.pos))
            return iterate.REMOVE        
    // collide with buildings
    for building in buildings:
        if overlaps(missile, building, false):
            building.destroyed = true
            todo("buildings should test for overlap with explosions and explode themselves")
            push(explosions, make_explosion(missile.pos))
            return iterate.REMOVE
    // collide with ground
    if missile.pos.y ≥ GROUND_Y:
        push(explosions, make_explosion(missile.pos))
        return iterate.REMOVE
    // disappear on edge of screen
    if ( missile.pos.x < 0 ) or ( missile.pos.x > SCREEN_SIZE.x ) or ( missile.pos.y < -max(EXPLOSION_MAX_RADIUS, PORTAL_RADIUS) ):
        return iterate.REMOVE

def make_portal(pos):
    return make_entity({
        pos:pos,
        z: 2,
        shape:"disk",
        name:"Portal",
        radius: PORTAL_RADIUS,
        size: PORTAL_RADIUS*xy(2,2),
        anchorTheta: -0.5 * π,
        anchorTarget: lerp( -π, π, ξ ),
        anchorDriftSpeed: lerp( PORTAL_ANGLE_DRIFT_SPEED_MIN, PORTAL_ANGLE_DRIFT_SPEED_MAX, ξ ),
        driftWait: lerp( PORTAL_DRIFT_WAIT_INITIAL_MIN_FRAMES, PORTAL_DRIFT_WAIT_INITIAL_MAX_FRAMES, ξ ),
        positionDriftCenter: random_point_in_band_from_pos( pos, PORTAL_POS_DRIFT_SOURCE_DISTANCE.x, PORTAL_POS_DRIFT_SOURCE_DISTANCE.y ),
        doesDrift: false,
        isCollapsing: false,
        buddy: ∅,
        spawn_f: mode_frames,
    })
def itor_portal_update(portal):
    assert(portal.buddy ≠ 0, "All portals in the portal[] list must have a buddy")
    //If we do drift, either count down to our next drift, or start modifying our angle and position.
    if portal.doesDrift:
        if portal.driftWait > 0:
            --portal.driftWait
        else:
            const angleBetween = loop( portal.anchorTarget - portal.anchorTheta, -π, π)
            portal.anchorTheta = lerp_angle( portal.anchorTheta, portal.anchorTarget, clamp( portal.anchorDriftSpeed / max( 0.001, abs( angleBetween ) ), 0, 1 ) )
            push_portal_from( portal, portal.positionDriftCenter, PORTAL_POS_DRIFT_PUSH_RANGE.x, PORTAL_POS_DRIFT_PUSH_RANGE.y, PORTAL_POS_DRIFT_PUSH_POWER )
    //If we've reached both our angle and position goals, consider this drift over, set new values, and pass the baton to our buddy.
    if ( portal.anchorTarget == portal.anchorTheta ) and ( magnitude( portal.pos - portal.positionDriftCenter ) > PORTAL_POS_DRIFT_PUSH_THRESHOLD ):
        portal.anchorTarget = lerp( -π, π, ξ )
        portal.anchorDriftSpeed = lerp( PORTAL_ANGLE_DRIFT_SPEED_MIN, PORTAL_ANGLE_DRIFT_SPEED_MAX, ξ )
        portal.positionDriftCenter = random_point_in_band_from_pos( portal.pos, PORTAL_POS_DRIFT_SOURCE_DISTANCE.x, PORTAL_POS_DRIFT_SOURCE_DISTANCE.y )
        portal.driftWait = lerp( PORTAL_DRIFT_WAIT_FRAMES.x, PORTAL_DRIFT_WAIT_FRAMES.y, ξ )
        portal.doesDrift = not portal.doesDrift
        portal.buddy.doesDrift = not portal.buddy.doesDrift
        
    //Then do position pushes from buildings
    for building in buildings:
        push_portal_from( portal, building.pos, BUILDING_PUSH_RADIUS_INNER, BUILDING_PUSH_RADIUS_OUTER, BUILDING_PUSH_AMOUNT )
    //Push away from other portals
    for otherPortal in portals:
        if otherPortal ≠ portal:
            push_portal_from( portal, otherPortal.pos, otherPortal.radius, otherPortal.radius + PORTAL_PUSH_RADIUS_ADDITION_OUTER, PORTAL_PUSH_AMOUNT )
    //Shrink portals if they're collapsing
    if portal.isCollapsing:
        portal.radius = max( 0, portal.radius - PORTAL_COLLAPSE_SPEED_PER_FRAME )
        if portal.radius == 0:
            return iterate.REMOVE
        portal.size = portal.radius * xy(2,2)
    //Check for situations that would cause the portal to collapse (eg hitting ground or edge of screen)
    if ( portal.pos.y ≥ GROUND_Y ) or ( portal.pos.x < 0 ) or ( portal.pos.x > SCREEN_SIZE.x ) or ( portal.pos.y < 0 ):
        portal.isCollapsing = true
        portal.buddy.isCollapsing = true

def push_portal_from(portal, pushSource, pushInnerRadius, pushOuterRadius, pushAmountAtInner):
    const vecToPortalFromSource = portal.pos - pushSource
    const distanceBetweenPortalAndSource = magnitude( vecToPortalFromSource )
    if ( distanceBetweenPortalAndSource > pushOuterRadius ) or ( portal.pos == pushSource ):
        return
    const pushPower = lerp( pushAmountAtInner, 0, max( distanceBetweenPortalAndSource - pushInnerRadius, 0 ) / ( pushOuterRadius - pushInnerRadius ) )
    portal.pos += pushPower * vecToPortalFromSource / distanceBetweenPortalAndSource

def random_point_in_band_from_pos( pos, radiusInner, radiusOuter ):
    return pos + ( lerp( radiusInner, radiusOuter, ξ ) * angle_to_xy( lerp( -π, π, ξ ) ) )

def itor_portal_draw(portal):
    //debug to see point of drift - draw_disk({pos:portal.positionDriftCenter, z:portal.z + 2, radius:4, color: #f00, outline:#f00})
    // A portal with an unplaced buddy will still be passed to this function, so we must check for null buddy here.
    if portal.buddy == ∅:
        draw_disk({pos:portal.pos, z:portal.z, radius:PORTAL_RADIUS, color: #0000, outline:#248})
    else:
        //While the portal is changing its output direction, show it in red
        draw_disk({pos:portal.pos, z:portal.z, radius:portal.radius, color: if portal.driftWait > 0 then #48c else #c44, 
            outline: if portal.driftWait > 0 then #248 else #822})
        //We then make a constant line effect that zips between the two portals
        const edge_offset_mag = cos( 0.5 * π * loop( game_frames / WARP_CONNECTION_OFFSET_BREATHE_FRAMES ) )
        const grey_to_use = WARP_CONNECTION_MAX_OPACITY * edge_offset_mag
        let dir_to_buddy = portal.buddy.pos - portal.pos
        dir_to_buddy = edge_offset_mag * dir_to_buddy / magnitude( dir_to_buddy )
        const portal_edge_offset = xy( -1 * dir_to_buddy.y, dir_to_buddy.x ) * portal.radius
        //The buddy portal will draw the opposite offset edge from this
        const color_to_use = perceptual_lerp_color( #000, #48c, grey_to_use )
        draw_line({A: portal.pos + portal_edge_offset, B: portal.buddy.pos + portal_edge_offset, z: portal.z - 1, width: 1, color:color_to_use})
        //Next we draw the anchor line
        const anchorEndpoint = portal.pos + ( portal.radius * angle_to_xy( portal.anchorTheta )  ) // )
        draw_line({A: portal.pos, B: anchorEndpoint, z: portal.z + 1, width: 2, color: gray(1) })

let explosions = []
let buildings = []
let missiles = []
let portals = []
let current_portal = nil
let cursor_pos = 50% SCREEN_SIZE
let game_over_hook = nil

enter
────────────────────────────────────────────────────────────────────────
explosions = []
buildings = []
missiles = []
portals = []
current_portal = nil
cursor_pos = 50% SCREEN_SIZE
game_over_hook = nil

// create building entities
for x in [64, 128, 192, 256, 320]:
    push(buildings, make_building(xy(x, GROUND_Y-4)))

set_post_effects({bloom: 100%})

frame
────────────────────────────────────────────────────────────────────────

song_update()

// handle input
cursor_pos.x = clamp(cursor_pos.x + (CURSOR_SPEED * joy.x), 0, SCREEN_SIZE.x-1)
cursor_pos.y = clamp(cursor_pos.y + (CURSOR_SPEED * joy.y), 0, SCREEN_SIZE.y-1)
if joy.aa:
    //push(explosions, make_explosion(cursor_pos))
    let portal = make_portal(cursor_pos)
    if current_portal == ∅: // first in pair
        current_portal = portal
        play_sound({pan: lerp(-100%, 100%, cursor_pos.x, 0, SCREEN_SIZE.x),
            ...SND_PORTAL_PLACE1})
    else: // second in pair
        portal.buddy = current_portal
        current_portal.buddy = portal
        current_portal.spawn_f = mode_frames
        //Choose one portal or the other to drift
        if ( ξ > 0.5 ):
            portal.doesDrift = true
        else:
            current_portal.doesDrift = true
        // add both portals to the master list
        push(portals, current_portal, portal)
        current_portal = ∅
        play_sound({pan: lerp(-100%, 100%, cursor_pos.x, 0, SCREEN_SIZE.x),
            ...SND_PORTAL_PLACE2})

// randomly spawn a new missile
if size(missiles) < MAX_MISSILE_COUNT and ξ < 0.003:
    const missile = make_missile()
    if missile ≠ ∅:
        push(missiles, missile)
// Grow/prune explosions
iterate(explosions, itor_explosion_update)
// Shrink/prune portals
iterate(portals, itor_portal_update)
// Advance missiles & check for impact
iterate(missiles, itor_missile_update)
// Destroy any buildings that were hit by missiles
iterate(buildings, itor_building_destroy)

// Check for game over
if size(buildings) == 0 and game_over_hook == nil:
    game_over_hook = add_frame_hook(fade_out, enter_gameover_mode, 2*60, ∅, {})

// Rendering
// cursor
draw_line({A:cursor_pos-xy(3,0), B:cursor_pos+xy(3,0), z:10, color:#f})
draw_line({A:cursor_pos-xy(0,3), B:cursor_pos+xy(0,3), z:10, color:#f})
// ground
//draw_corner_rect({corner:xy(0,GROUND_Y), size:xy(SCREEN_SIZE.x, 16), z:0, color:#242})
for GROUND_Y ≤ y < SCREEN_SIZE.y:
    const iy = y - GROUND_Y
    draw_map_span(xy(0,y), xy(SCREEN_SIZE.x,0), ground_map,
        xy((2*iy) + mode_frames/2,2*iy) / ground_map.sprite_size, xy(192-(2*iy) + mode_frames/2,2*iy) / ground_map.sprite_size)
// buildings
for building in buildings:
    draw_entity(building)
    todo("Draw occasional chat messages from buildings in a tiny font")
// explosions
iterate(explosions, itor_explosion_draw)
// missiles
iterate(missiles, itor_missile_draw)
// portals
iterate(portals, itor_portal_draw)
if current_portal ≠ ∅:
    itor_portal_draw(current_portal)
if DEBUG_MUSIC:
    bgm_draw_debug()

leave
────────────────────────────────────────────────────────────────────────
reset_post_effects()
remove_frame_hooks_by_mode(get_mode())
