Play
════════════════════════════════════════════════════════════════════════

const BLOCK_SIZE = xy(16,16)
const HERO_SPRITE = hero_sprite
const ALL_MAPS = [
    prototype_map,
    basicpuzzle1_map,
    basicpuzzle2_map,
]
const MAP_INDEX = 1
const HERO_SPAWN_SPRITE = ALL_MAPS[MAP_INDEX].spritesheet.player_start
const GOAL_SPRITE = ALL_MAPS[MAP_INDEX].spritesheet.goal

def map_offset(m):
    const screen_size_in_blocks = SCREEN_SIZE / BLOCK_SIZE
    const map_size_in_blocks = map.size
    return xy(2, 2) * BLOCK_SIZE
def map_pos_to_cell(pos):
    return round(pos / BLOCK_SIZE)
def map_cell_to_pos(cell):
    return BLOCK_SIZE * cell
    
// gets the value of the map cell from a world-space coordinate.
// Only the sign of vel is used, to check the correct direction; its magnitude is ignored.
def map_sprite(pos, vel default xy(0, 0)):
    return get_map_sprite(map, map_pos_to_cell(pos) + sign(vel), 0)
    
def is_cell_solid(icell):
    // look up the actual column data for this cell
    if icell.x < 0 or icell.x ≥ size(map_src_columns) or icell.y < 0 or icell.y ≥ map.size.y:
        return true
    const src_x = map_src_columns[icell.x]
    const ms = get_map_sprite(map, xy(src_x, icell.y), 0)
    // For now, if there's a sprite in this cell, it's solid. If necessary, we could tag
    // certain sprites as passable in the sprite sheet.
    return ms ≠ ∅ and not ms.passable

def is_point_in_solid_cell(p):
        const c = map_pos_to_cell(p)
        return is_cell_solid(c)
def is_hero_on_ground(h):
    // If y pos isn't exactly in the middle of the cell, we're not on the ground.
    if h.pos.y % BLOCK_SIZE.y ≠ 0:
        return false
    // test the left foot and right foot pos, plus the pixels directly below them.
    // If the bottom point is in a solid cell and the top point isn't (on either side),
    // we're on the ground.
    const pos_l = h.pos + xy(-h.size.x/2, +h.size.y/2 - 1)
    if not is_point_in_solid_cell(pos_l) and is_point_in_solid_cell(pos_l+xy(0,1)):
        return true
    const pos_r = h.pos + xy(+h.size.x/2, +h.size.y/2- 1)
    if not is_point_in_solid_cell(pos_r) and is_point_in_solid_cell(pos_r+xy(0,1)):
        return true
    return false
def is_hero_on_wall(h):
    // TODO: x equivalent of this early-out
    // If y pos isn't exactly in the middle of the cell, we're not on the ground.
    //if h.pos.y % BLOCK_SIZE.y ≠ 0:
    //    return false
    // test the left foot and right foot pos, plus the pixels directly below them.
    // If the bottom point is in a solid cell and the top point isn't (on either side),
    // we're on the ground.
    if h.dir > 0: // facing right
        const pos_t = h.pos + xy(+h.size.x/2-1, -(h.size.y/2 - 1))
        if not is_point_in_solid_cell(pos_t) and is_point_in_solid_cell(pos_t+xy(1,0)):
            return true
        const pos_b = h.pos + xy(+h.size.x/2-1, +(h.size.y/2 - 1))
        if not is_point_in_solid_cell(pos_b) and is_point_in_solid_cell(pos_b+xy(1,0)):
            return true
    else:
        const pos_t = h.pos - xy(+h.size.x/2, -(h.size.y/2 - 1))
        if not is_point_in_solid_cell(pos_t) and is_point_in_solid_cell(pos_t-xy(1,0)):
            return true
        const pos_b = h.pos - xy(+h.size.x/2, +(h.size.y/2 - 1))
        if not is_point_in_solid_cell(pos_b) and is_point_in_solid_cell(pos_b-xy(1,0)):
            return true
    return false
            
def clamp_hero_to_map(h):
    const pos_c = map_cell_to_pos(map_pos_to_cell(h.pos))
    while true:
        let dx = ∞
        let dy = ∞
        let gx = 0
        let gy = 0
        if h.vel.x > 0:
            const pos_tr = h.pos + xy(+h.size.x/2, -h.size.y/2) + xy(-1,+1)
            const pos_br = h.pos + xy(+h.size.x/2, +h.size.y/2) + xy(-1,-1)
            if is_point_in_solid_cell(pos_tr) or is_point_in_solid_cell(pos_br):
                gx = pos_c.x + (BLOCK_SIZE.x/2 - h.size.x/2)
                dx = abs(h.pos.x - gx)
        else if h.vel.x < 0:
            const pos_tl = h.pos + xy(-h.size.x/2, -h.size.y/2) + xy(+1,+1)
            const pos_bl = h.pos + xy(-h.size.x/2, +h.size.y/2) + xy(+1,-1)
            if is_point_in_solid_cell(pos_tl) or is_point_in_solid_cell(pos_bl):
                gx = pos_c.x - (BLOCK_SIZE.x/2 - h.size.x/2)
                dx = abs(h.pos.x - gx)
        if h.vel.y > 0:
            const pos_bl = h.pos + xy(-h.size.x/2, +h.size.y/2) + xy(+1,-1)
            const pos_br = h.pos + xy(+h.size.x/2, +h.size.y/2) + xy(-1,-1)
            if is_point_in_solid_cell(pos_bl) or is_point_in_solid_cell(pos_br):
                gy = pos_c.y + (BLOCK_SIZE.y/2 - h.size.y/2)
                dy = abs(h.pos.y - gy)
        else if h.vel.y < 0:
            const pos_tl = h.pos + xy(-h.size.x/2, -h.size.y/2) + xy(+1,+1)
            const pos_tr = h.pos + xy(+h.size.x/2, -h.size.y/2) + xy(-1,+1)
            if is_point_in_solid_cell(pos_tl) or is_point_in_solid_cell(pos_tr):
                gy = pos_c.y - (BLOCK_SIZE.y/2 - h.size.y/2)
                dy = abs(h.pos.y - gy)
        if (dx == 0 and dy == 0) or (dx == ∞ and dy == ∞):
            return
        else if dx < dy:
            h.pos.x = gx
            h.vel.x = 0
        else:
            h.pos.y = gy
            h.vel.y = 0

// GLOBALS
// The *_grid arrays are 2D arrays. Unless otherwise mentioned, grid[x][y]
// stores a reference to the entity of that type in map cell x,y, or ∅ if
// the cell does not contain an entity of that type.
let map = ∅
let map_xform = xy(0,0)
let map_src_columns = [] // index of the column data from map to draw for each on-screen column
let hero = ∅
let devoured_src_column = -1 // -1 = nothing devoured; otherwise it's the src column index

enter
────────────────────────────────────────────────────────────────────────
map = ∅
map_xform = xy(0,0)
map_src_columns = []
hero = ∅
devoured_src_column = -1

map = deep_clone(ALL_MAPS[MAP_INDEX])
map_xform = map_offset(map)
// initialize map source columns
resize(map_src_columns, map.size.x)
for x < map.size.x:
    map_src_columns[x] = x

// Search map for special cells, so we can replace them with entities and
// overwrite them in the map data
let hero_start_icell = xy(0,0)
let goal_icell = xy(0,0)
for mx < map.size.x:
    for my < map.size.y:
        const icell = xy(mx,my)
        const ms = map[mx][my]
        if ms == HERO_SPAWN_SPRITE:
            hero_start_icell = icell
            set_map_sprite(map, icell, nil)
        if ms == GOAL_SPRITE:
            goal_icell = icell
            //set_map_sprite(map, icell, nil)

hero = make_entity({
    pos: map_cell_to_pos(hero_start_icell),
    name: "Hero",
    sprite: HERO_SPRITE.right[0],
    scale: xy(1,1),
    size: xy(8,16),
    dir: +1,
    z: 1,
})

frame
────────────────────────────────────────────────────────────────────────

// update hero
local:
    if joy.xx:
        hero.dir = joy.xx
    const anim = if hero.dir == 1 then HERO_SPRITE.right else HERO_SPRITE.left
    hero.sprite = if (joy.xx or joy.x) then anim.frame(mode_frames) else anim.frame(0)
    if not is_hero_on_wall(hero):
        hero.vel.x = joy.x * 0.7
    // jumping/gravity
    const is_on_ground = is_hero_on_ground(hero)
    if is_on_ground:
        hero.vel.y = if joy.aa then -JUMP_VEL else 0
    else:
        hero.force.y = GRAVITY_FORCE
    // apply forces & velocity
    entity_simulate(hero)
    clamp_hero_to_map(hero)
    
// identify target column
let target_column_index = 0
local:
    const hero_icell = map_pos_to_cell(hero.pos)
    if devoured_src_column < 0:
        target_column_index = hero_icell.x//clamp(if hero.dir > 0 then hero_icell.x+1 else hero_icell.x-1, 0, map.size.x-1)
    else:
        target_column_index = clamp(if hero.dir > 0 then hero_icell.x+1 else hero_icell.x, 0, map.size.x-1)
    
// remove/insert column with B
if joy.bb:
    if devoured_src_column < 0: // devour
        devoured_src_column = map_src_columns[target_column_index]
        remove_key(map_src_columns, target_column_index)
        map_xform.x += BLOCK_SIZE.x // keep map right-aligned
        // TODO: push hero back if they're now standing in a wall
        const hero_icell = map_pos_to_cell(hero.pos)
        if is_cell_solid(hero_icell):
            if not is_cell_solid(hero_icell + xy(-1,0)):
                hero.pos = map_cell_to_pos(hero_icell + xy(-1,0))
            else if not is_cell_solid(hero_icell + xy(+1,0)):
                hero.pos = map_cell_to_pos(hero_icell + xy(+1,0))
            else:
                debug_print("Squish")
        if hero.dir < 0:
            hero.pos.x -= BLOCK_SIZE.x // maintain hero's map-relative position
    else: // regurgitate
        insert(map_src_columns, target_column_index, devoured_src_column)
        devoured_src_column = -1
        map_xform.x -= BLOCK_SIZE.x // keep map right-aligned
        // TODO: push hero back if they're now standing in a wall
        if hero.dir < 0:
            hero.pos.x += BLOCK_SIZE.x // maintain hero's map-relative position

set_background(rgb(20%, 60%, 90%))
preserving_transform:
    set_transform(map_xform)
    // Offset by ½ a grid square so that we can use integer coordinates for the centers of grid tiles
    compose_transform(0.5 BLOCK_SIZE)
    // Draw map by reading columns of sprites from the source data, in the order specified in map_src_columns
    for src_x at x in map_src_columns:
        for 0 ≤ y ≤ map.size.y:
            const ms = get_map_sprite(map, xy(src_x, y), 0)
            if ms ≠ ∅:
                draw_sprite({sprite:ms, pos:xy(BLOCK_SIZE.x*x, BLOCK_SIZE.y*y), z:0})
    // Highlight the target column
    local:
        const corner = xy(BLOCK_SIZE.x*target_column_index, 0) - ½ BLOCK_SIZE
        if devoured_src_column < 0:
            draw_corner_rect({corner:corner, size:xy(BLOCK_SIZE.x, BLOCK_SIZE.y*map.size.y), color:∅, outline:#ff0})
        else:
            draw_line({A:corner, B:corner+xy(0,BLOCK_SIZE.y*map.size.y), width:2, color:#ff0})
    
    // Draw hero
    draw_sprite(hero)
// UI
draw_corner_rect({corner:xy(0,0), size:xy(2*BLOCK_SIZE.x, SCREEN_SIZE.y), color:#0, z:100})
draw_corner_rect({corner:xy(0,0), size:xy(SCREEN_SIZE.x, 2*BLOCK_SIZE.y), color:#0, z:100})
