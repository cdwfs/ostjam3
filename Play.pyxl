Play
════════════════════════════════════════════════════════════════════════

const GROUND_Y = SCREEN_SIZE.y-16
const EXPLOSION_DURATION = 120
const EXPLOSION_MAX_RADIUS = 32
const PORTAL_RADIUS = 16
const WARP_DURATION = 60

def make_building(pos):
  return make_entity({
        pos: pos,
        z: 1,
        name: "Building",
        shape: "rect",
        sprite: prototype_blocks_sprite[3][0],
    })
def itor_building_destroy(building):
    if building.destroyed:
        return iterate.REMOVE
    
def make_explosion(pos):
    return make_entity({
        pos: pos,
        size: xy(0,0),
        radius: 0,
        z: 2,
        shape: "disk",
        name:"Explosion",
        start_f: mode_frames,
        end_f: mode_frames+EXPLOSION_DURATION,
    })
def itor_explosion_draw(e):
    draw_disk({pos:e.pos, radius:e.radius, color:#c84, outline:#f80, z:e.z})
def itor_explosion_update(e):
    const t = (mode_frames - e.start_f) / (e.end_f - e.start_f)
    if t ≥ 1.0:
        return iterate.REMOVE
    e.radius = EXPLOSION_MAX_RADIUS * t
    e.size = xy(2*e.radius, 2*e.radius)

    
def make_missile():
    const target_building = random_value(buildings)
    if target_building == ∅:
        return // no buildings left to shoot at
    // spawn far enough off-screen to ensure w don't spawn inside a portal or explosion
    const missile_pos = xy(random_integer(0, SCREEN_SIZE.x-1), -max(EXPLOSION_MAX_RADIUS, PORTAL_RADIUS))
    const missile_dir = direction(target_building.pos - missile_pos)
    return make_entity({
        pos: missile_pos,
        z:2,
        size: xy(3,3),
        shape: "rect",
        dir: missile_dir,
        trail_start_pos: missile_pos,
        trail_lines: [],
        vel: MISSILE_SPEED*missile_dir,
        portal: ∅,
        portal_enter_f: -1,
    })
def itor_missile_draw(m):
    // draw missile
    if m.portal ≠ ∅: // ghost missile, mid-warp
        const src_pos = m.portal.pos
        const dst_pos = m.portal.buddy.pos
        const ghost_pos = lerp(src_pos, dst_pos, mode_frames, m.portal_enter_f, m.portal_enter_f+WARP_DURATION)
        draw_rect({pos:ghost_pos, size:m.size, color:#88f, z:m.z})
    else: // normal missile
        draw_rect({pos:m.pos, size:m.size, color:#f00, z:m.z})
    // draw trail
    if not m.is_in_portal:
        draw_line({A:m.pos, B:m.trail_start_pos, z:0, color:#800})
    for line in m.trail_lines:
        draw_line({A:line.A, B:line.B, z:0, color:#800})
    
def itor_missile_update(missile):
    // handle exiting the portal
    if missile.portal ≠ ∅:
        if mode_frames - missile.portal_enter_f ≥ WARP_DURATION:
            missile.pos = missile.portal.buddy.pos + (missile.portal.buddy.radius+1) * missile.dir
            missile.trail_start_pos = clone(missile.pos)
            missile.portal = ∅
            missile.portal_enter_f = -1
        else:
            return iterate.CONTINUE // no further processing for missiles mid-warp
    
    missile.pos += missile.vel
    // collide with portals
    for portal in portals:
        if overlaps(missile.pos, portal):
            push(missile.trail_lines, {A:clone(missile.trail_start_pos), B:clone(missile.pos)})
            missile.portal = portal
            missile.portal_enter_f = mode_frames
            return iterate.CONTINUE // skip remaining checks when entering a portal        

    // collide with explosions
    if not missile.is_in_portal:
        let hit_explosion = false
        for explosion in explosions:
            if overlaps(missile, explosion, false):
                hit_explosion = true
                break
        if hit_explosion:
            push(explosions, make_explosion(missile.pos))
            return iterate.REMOVE        
    // collide with buildings
    for building in buildings:
        if overlaps(missile, building, false):
            building.destroyed = true
            push(explosions, make_explosion(missile.pos))
            return iterate.REMOVE
    // collide with ground
    if missile.pos.y ≥ GROUND_Y:
        push(explosions, make_explosion(missile.pos))
        return iterate.REMOVE

def make_portal(pos):
    return make_entity({
        pos:pos,
        z: 2,
        shape:"disk",
        name:"Portal",
        radius: PORTAL_RADIUS,
        size: PORTAL_RADIUS*xy(2,2),
        buddy: ∅,
        spawn_f: mode_frames,
    })
def itor_portal_update(portal):
    if portal.buddy ≠ ∅:
        portal.radius = lerp(PORTAL_RADIUS, 0, mode_frames, portal.spawn_f, portal.spawn_f + 10*60)
        if portal.radius == 0:
            return iterate.REMOVE
        portal.size = portal.radius * xy(2,2)
def itor_portal_draw(portal):
    if portal.buddy == ∅:
        draw_disk({pos:portal.pos, z:portal.z, radius:PORTAL_RADIUS, color: #0000, outline:#248})
    else:
        draw_disk({pos:portal.pos, z:portal.z, radius:portal.radius, color: #48c, outline:#248})

let explosions = []
let buildings = []
let missiles = []
let portals = []
let current_portal = nil
let cursor_pos = 50% SCREEN_SIZE

enter
────────────────────────────────────────────────────────────────────────
explosions = []
buildings = []
missiles = []
portals = []
current_portal = nil
cursor_pos = 50% SCREEN_SIZE

// create building entities
for x in [64, 128, 192, 256, 320]:
    push(buildings, make_building(xy(x, GROUND_Y-4)))
    
play_sound({sound: music_loop1_sound, loop: true})

frame
────────────────────────────────────────────────────────────────────────

// handle input
cursor_pos.x = clamp(cursor_pos.x + joy.x, 0, SCREEN_SIZE.x-1)
cursor_pos.y = clamp(cursor_pos.y + joy.y, 0, SCREEN_SIZE.y-1)
if joy.aa:
    //push(explosions, make_explosion(cursor_pos))
    let portal = make_portal(cursor_pos)
    if current_portal == ∅: // first in pair
        current_portal = portal
    else: // second in pair
        portal.buddy = current_portal
        current_portal.buddy = portal
        current_portal.spawn_f = mode_frames
        // add both portals to the master list
        push(portals, current_portal, portal)
        current_portal = ∅

// randomly spawn a new missile
if size(missiles) < MAX_MISSILE_COUNT and ξ < 0.003:
    const missile = make_missile()
    if missile ≠ ∅:
        push(missiles, missile)
// Grow/prune explosions
iterate(explosions, itor_explosion_update)
// Shrink/prune portals
iterate(portals, itor_portal_update)
// Advance missiles & check for impact
iterate(missiles, itor_missile_update)
// Destroy any buildings that were hit by missiles
iterate(buildings, itor_building_destroy)

// Rendering
// cursor
draw_line({A:cursor_pos-xy(3,0), B:cursor_pos+xy(3,0), z:10, color:#f})
draw_line({A:cursor_pos-xy(0,3), B:cursor_pos+xy(0,3), z:10, color:#f})
// ground
draw_corner_rect({corner:xy(0,GROUND_Y), size:xy(SCREEN_SIZE.x, 16), z:0, color:#242})
// buildings
for building in buildings:
    draw_entity(building)
// explosions
iterate(explosions, itor_explosion_draw)
// missiles
iterate(missiles, itor_missile_draw)
// portals
iterate(portals, itor_portal_draw)
if current_portal ≠ ∅:
    itor_portal_draw(current_portal)
