Play
════════════════════════════════════════════════════════════════════════

const GROUND_Y = SCREEN_SIZE.y-16
const EXPLOSION_DURATION = 90
const EXPLOSION_MAX_RADIUS = 24
const PORTAL_RADIUS = 16
const WARP_DURATION = 45
const CURSOR_SPEED = 2.5
const WARP_CONNECTION_COLOR_BREATHE_FRAMES = 120
const WARP_CONNECTION_OFFSET_BREATHE_FRAMES = 70
const WARP_CONNECTION_MAX_OPACITY = 0.3
const PORTAL_LIFETIME_FRAMES = 1800
const PORTAL_DRIFT_WAIT_INITIAL_MAX_FRAMES = 400
const PORTAL_DRIFT_WAIT_INITIAL_MIN_FRAMES = 150
const PORTAL_DRIFT_WAIT_MIN_FRAMES = 150
const PORTAL_DRIFT_WAIT_MAX_FRAMES = 300
const PORTAL_ANGLE_DRIFT_SPEED_MAX = 0.004 * π
const PORTAL_ANGLE_DRIFT_SPEED_MIN = 0.003 * π

def make_building(pos):
  return make_entity({
        pos: pos,
        z: 1,
        name: "Building",
        shape: "rect",
        sprite: prototype_blocks_sprite[3][0],
    })
def itor_building_destroy(building):
    if building.destroyed:
        return iterate.REMOVE
    
def make_explosion(pos):
    return make_entity({
        pos: pos,
        size: xy(0,0),
        radius: 0,
        z: 2,
        shape: "disk",
        name:"Explosion",
        start_f: mode_frames,
        end_f: mode_frames+EXPLOSION_DURATION,
    })
def itor_explosion_draw(e):
    draw_disk({pos:e.pos, radius:e.radius, color:#c84, outline:#f80, z:e.z})
def itor_explosion_update(e):
    const t = (mode_frames - e.start_f) / (e.end_f - e.start_f)
    if t ≥ 1.0:
        return iterate.REMOVE
    e.radius = EXPLOSION_MAX_RADIUS * t
    e.size = xy(2*e.radius, 2*e.radius)

    
def make_missile():
    const target_building = random_value(buildings)
    // spawn far enough off-screen to ensure w don't spawn inside a portal or explosion
    const missile_pos = xy(random_integer(0, SCREEN_SIZE.x-1), -max(EXPLOSION_MAX_RADIUS, PORTAL_RADIUS))
    const missile_dir = direction(target_building.pos - missile_pos)
    return make_entity({
        pos: missile_pos,
        z:2,
        size: xy(3,3),
        shape: "rect",
        dir: missile_dir,
        trail_start_pos: missile_pos,
        trail_lines: [],
        vel: MISSILE_SPEED*missile_dir,
        portal: ∅,
        portal_enter_f: -1,
    })
def itor_missile_draw(m):
    // draw missile
    if m.portal ≠ ∅: // ghost missile, mid-warp
        const src_pos = m.portal.pos
        const dst_pos = m.portal.buddy.pos
        const ghost_pos = lerp(src_pos, dst_pos, mode_frames, m.portal_enter_f, m.portal_enter_f+WARP_DURATION)
        draw_rect({pos:ghost_pos, size:m.size, color:#88f, z:m.z})
    else: // normal missile
        draw_rect({pos:m.pos, size:m.size, color:#f00, z:m.z})
    // draw trail
    if not m.is_in_portal:
        draw_line({A:m.pos, B:m.trail_start_pos, z:0, color:#800})
    for line in m.trail_lines:
        draw_line({A:line.A, B:line.B, z:0, color:#800})
    
def itor_missile_update(missile):
    // handle exiting the portal
    if missile.portal ≠ ∅:
        if mode_frames - missile.portal_enter_f ≥ WARP_DURATION:
            missile.pos = missile.portal.buddy.pos + (missile.portal.buddy.radius+1) * missile.dir
            missile.trail_start_pos = clone(missile.pos)
            missile.portal = ∅
            missile.portal_enter_f = -1
        else:
            return iterate.CONTINUE // no further processing for missiles mid-warp
    
    missile.pos += missile.vel
    // collide with portals
    for portal in portals:
        if overlaps(missile.pos, portal):
            push(missile.trail_lines, {A:clone(missile.trail_start_pos), B:clone(missile.pos)})
            missile.portal = portal
            missile.portal_enter_f = mode_frames
            return iterate.CONTINUE // skip remaining checks when entering a portal        

    // collide with explosions
    if not missile.is_in_portal:
        let hit_explosion = false
        for explosion in explosions:
            if overlaps(missile, explosion, false):
                hit_explosion = true
                break
        if hit_explosion:
            push(explosions, make_explosion(missile.pos))
            return iterate.REMOVE        
    // collide with buildings
    for building in buildings:
        if overlaps(missile, building, false):
            building.destroyed = true
            push(explosions, make_explosion(missile.pos))
            return iterate.REMOVE
    // collide with ground
    if missile.pos.y ≥ GROUND_Y:
        push(explosions, make_explosion(missile.pos))
        return iterate.REMOVE

def make_portal(pos):
    return make_entity({
        pos:pos,
        z: 2,
        shape:"disk",
        name:"Portal",
        radius: PORTAL_RADIUS,
        size: PORTAL_RADIUS*xy(2,2),
        anchorTheta: -0.5 * π,
        anchorTarget: lerp( -π, π, ξ ),
        anchorDriftSpeed: lerp( PORTAL_ANGLE_DRIFT_SPEED_MIN, PORTAL_ANGLE_DRIFT_SPEED_MAX, ξ ),
        anchorDriftWait: lerp( PORTAL_DRIFT_WAIT_INITIAL_MIN_FRAMES, PORTAL_DRIFT_WAIT_INITIAL_MAX_FRAMES, ξ ),
        doesDrift: false,
        buddy: ∅,
        spawn_f: mode_frames,
    })
def itor_portal_update(portal):
    //First do anchor drift
    if portal.buddy ≠ ∅:
        if portal.anchorTarget == portal.anchorTheta:
            portal.anchorTarget = lerp( -π, π, ξ )
            portal.anchorDriftSpeed = lerp( PORTAL_ANGLE_DRIFT_SPEED_MIN, PORTAL_ANGLE_DRIFT_SPEED_MAX, ξ )
            portal.anchorDriftWait = lerp( PORTAL_DRIFT_WAIT_MIN_FRAMES, PORTAL_DRIFT_WAIT_MAX_FRAMES, ξ )
        if portal.doesDrift:
            if portal.anchorDriftWait > 0:
                --portal.anchorDriftWait
            else:
                const angleBetween = loop( portal.anchorTarget - portal.anchorTheta, -π, π)
                portal.anchorTheta = lerp_angle( portal.anchorTheta, portal.anchorTarget, clamp( portal.anchorDriftSpeed / max( 0.001, abs( angleBetween ) ), 0, 1 ) )
    //Then shrink portals if they're linked
    if portal.buddy ≠ ∅:
        portal.radius = lerp(PORTAL_RADIUS, 0, mode_frames, portal.spawn_f, portal.spawn_f + PORTAL_LIFETIME_FRAMES)
        if portal.radius == 0:
            return iterate.REMOVE
        portal.size = portal.radius * xy(2,2)
def itor_portal_draw(portal):
    if portal.buddy == ∅:
        draw_disk({pos:portal.pos, z:portal.z, radius:PORTAL_RADIUS, color: #0000, outline:#248})
    else:
        //While the portal is changing its output direction, show it in red
        draw_disk({pos:portal.pos, z:portal.z, radius:portal.radius, color: if portal.anchorDriftWait > 0 then #48c else #c44, 
            outline: if portal.anchorDriftWait > 0 then #248 else #822})
        //We then make a constant line effect that zips between the two portals
        const edge_offset_mag = cos( 0.5 * π * loop( game_frames / WARP_CONNECTION_OFFSET_BREATHE_FRAMES ) )
        const grey_to_use = WARP_CONNECTION_MAX_OPACITY * edge_offset_mag
        let dir_to_buddy = portal.buddy.pos - portal.pos
        dir_to_buddy = edge_offset_mag * dir_to_buddy / magnitude( dir_to_buddy )
        const portal_edge_offset = xy( -1 * dir_to_buddy.y, dir_to_buddy.x ) * portal.radius
        //The buddy portal will draw the opposite offset edge from this
        const color_to_use = perceptual_lerp_color( #000, #48c, grey_to_use )
        draw_line({A: portal.pos + portal_edge_offset, B: portal.buddy.pos + portal_edge_offset, z: portal.z - 1, width: 1, color:color_to_use})
        //Next we draw the anchor line
        const anchorEndpoint = portal.pos + ( portal.radius * angle_to_xy( portal.anchorTheta )  ) // )
        draw_line({A: portal.pos, B: anchorEndpoint, z: portal.z + 1, width: 2, color: gray(1) })

let explosions = []
let buildings = []
let missiles = []
let portals = []
let current_portal = nil
let cursor_pos = 50% SCREEN_SIZE

enter
────────────────────────────────────────────────────────────────────────
explosions = []
buildings = []
missiles = []
portals = []
current_portal = nil
cursor_pos = 50% SCREEN_SIZE

// create building entities
for x in [64, 128, 192, 256, 320]:
    push(buildings, make_building(xy(x, GROUND_Y-4)))
    
play_sound({sound: music_loop1_sound, loop: true})

frame
────────────────────────────────────────────────────────────────────────

// handle input
cursor_pos.x = clamp(cursor_pos.x + (CURSOR_SPEED * joy.x), 0, SCREEN_SIZE.x-1)
cursor_pos.y = clamp(cursor_pos.y + (CURSOR_SPEED * joy.y), 0, SCREEN_SIZE.y-1)
if joy.aa:
    //push(explosions, make_explosion(cursor_pos))
    let portal = make_portal(cursor_pos)
    if current_portal == ∅: // first in pair
        current_portal = portal
    else: // second in pair
        portal.buddy = current_portal
        current_portal.buddy = portal
        current_portal.spawn_f = mode_frames
        //Choose one portal or the other to drift
        if ( ξ > 0.5 ):
            portal.doesDrift = true
        else:
            current_portal.doesDrift = true
        // add both portals to the master list
        push(portals, current_portal, portal)
        current_portal = ∅

// randomly spawn a new missile
if size(missiles) < MAX_MISSILE_COUNT and ξ < 0.003:
    push(missiles, make_missile())
// Grow/prune explosions
iterate(explosions, itor_explosion_update)
// Shrink/prune portals
iterate(portals, itor_portal_update)
// Advance missiles & check for impact
iterate(missiles, itor_missile_update)
// Destroy any buildings that were hit by missiles
iterate(buildings, itor_building_destroy)

// Rendering
// cursor
draw_line({A:cursor_pos-xy(3,0), B:cursor_pos+xy(3,0), z:10, color:#f})
draw_line({A:cursor_pos-xy(0,3), B:cursor_pos+xy(0,3), z:10, color:#f})
// ground
draw_corner_rect({corner:xy(0,GROUND_Y), size:xy(SCREEN_SIZE.x, 16), z:0, color:#242})
// buildings
for building in buildings:
    draw_entity(building)
// explosions
iterate(explosions, itor_explosion_draw)
// missiles
iterate(missiles, itor_missile_draw)
// portals
iterate(portals, itor_portal_draw)
if current_portal ≠ ∅:
    itor_portal_draw(current_portal)
