Play
════════════════════════════════════════════════════════════════════════

const GROUND_Y = SCREEN_SIZE.y-16
const EXPLOSION_DURATION = 120
const EXPLOSION_MAX_RADIUS = 32
const PORTAL_RADIUS = 16

def make_building(pos):
  return make_entity({
        pos: pos,
        z: 1,
        name: "Building",
        shape: "rect",
        sprite: prototype_blocks_sprite[3][0],
    })
def itor_building_destroy(building):
    if building.destroyed:
        return iterate.REMOVE
    
def make_explosion(pos):
    return make_entity({
        pos: pos,
        size: xy(0,0),
        radius: 0,
        z: 2,
        shape: "disk",
        name:"Explosion",
        start_f: mode_frames,
        end_f: mode_frames+EXPLOSION_DURATION,
    })
def itor_explosion_draw(e):
    draw_disk({pos:e.pos, radius:e.radius, color:#c84, outline:#f80, z:e.z})
def itor_explosion_update(e):
    const t = (mode_frames - e.start_f) / (e.end_f - e.start_f)
    if t ≥ 1.0:
        return iterate.REMOVE
    e.radius = EXPLOSION_MAX_RADIUS * t
    e.size = xy(2*e.radius, 2*e.radius)

    
def make_missile():
    const target_building = random_value(buildings)
    // spawn far enough off-screen to ensure w don't spawn inside a portal or explosion
    const missile_pos = xy(random_integer(0, SCREEN_SIZE.x-1), -max(EXPLOSION_MAX_RADIUS, PORTAL_RADIUS))
    const missile_dir = direction(target_building.pos - missile_pos)
    let ray = {pos:missile_pos, dir:missile_dir}
    const hit_portal = ray_intersect(ray, portals)
    const enter_point = ray.pos + ray.length*ray.dir
    const exit_point = missile_portal_exit_point(missile_dir, hit_portal, enter_point)
    return make_entity({
        pos: missile_pos,
        z:2,
        size: xy(3,3),
        shape: "rect",
        dir: missile_dir,
        trail_start_pos: missile_pos,
        trail_lines: [],
        vel: MISSILE_SPEED*missile_dir,
        is_in_portal: false,
        next_portal: hit_portal,
        portal_enter_point: enter_point,
        portal_exit_point: exit_point,
    })
def missile_portal_exit_point(missile_dir, portal, enter_point):
    if portal == ∅:
        return enter_point
    // compute intersection on far side of portal. Need to get sneaky here as ray_intersect
    // treats the circle as solid & will report our current position as the exit point.
    // So instead, look ahead to a point beyond the diameter of the circle along the ray,
    // and then trace backwards.
    let ray = {pos:enter_point + 3*portal.radius*missile_dir, dir:-missile_dir}
    let hit_portal = ray_intersect(ray, portal)
    return if hit_portal ≠ ∅ then ray.pos + ray.dir * ray.length else clone(enter_point)    
def itor_missile_draw(m):
    // draw missile
    draw_rect({pos:m.pos, size:m.size, color:#f00, z:m.z})
    // draw trail
    draw_line({A:m.pos, B:m.trail_start_pos, z:0, color:#800})
    for line in m.trail_lines:
        draw_line({A:line.A, B:line.B, z:0, color:#800})
    if DEBUG_DRAW_MISSILE_TARGETS:
        draw_line({A:m.pos, B: if m.next_portal ≠ ∅ then m.portal_entry_point else m.pos+m.dir*1000, color:#f0f})
    
def itor_missile_update(missile):
    missile.pos += missile.vel
    // collide with portal
    if missile.next_portal ≠ ∅:
        // handle entering portal
        if not missile.is_in_portal and dot(missile.portal_entry_point - missile.pos, missile.dir) < 0:
            push(missile.trail_lines, {A:missile.trail_start_pos, B:missile.pos})
            missile.is_in_portal = true
        // handle exiting portal (may happen the same frame as the entry)
        if missile.is_in_portal and dot(missile.portal_exit_point - missile.pos, missile.dir) < 0:
            // warp to exit portal
            const offset = missile.pos - missile.next_portal.pos
            missile.pos = missile.next_portal.buddy.pos + offset
            // intersect with all portal *except* the one we just exited to see what's next
            let ray = {pos:missile.pos, dir:missile.dir}
            let portals_minus_exit = clone(portals)
            fast_remove_value(portals_minus_exit, missile.next_portal.buddy)
            missile.next_portal = ray_intersect(ray, portals_minus_exit)
            missile.portal_entry_point = ray.pos + ray.dir * ray.length
            missile.portal_exit_point = missile_portal_exit_point(missile.dir,
                missile.next_portal, missile.portal_entry_point)
            missile.trail_start_pos = clone(missile.pos)
            missile.is_in_portal = false
        
    // collide with explosions
    let hit_explosion = false
    for explosion in explosions:
        if overlaps(missile, explosion, false):
            hit_explosion = true
            break
    if hit_explosion:
        push(explosions, make_explosion(missile.pos))
        return iterate.REMOVE        
    // collide with buildings
    for building in buildings:
        if overlaps(missile, building, false):
            building.destroyed = true
            push(explosions, make_explosion(missile.pos))
            return iterate.REMOVE
    // collide with ground
    if missile.pos.y ≥ GROUND_Y:
        push(explosions, make_explosion(missile.pos))
        return iterate.REMOVE

def make_portal(pos):
    return make_entity({
        pos:pos,
        z: 2,
        shape:"disk",
        name:"Portal",
        radius: PORTAL_RADIUS,
        size: PORTAL_RADIUS*xy(2,2),
        buddy: nil
    })
def itor_portal_draw(portal):
    if portal.buddy == ∅:
        draw_disk({pos:portal.pos, z:portal.z, radius:portal.radius, color: #0000, outline:#248})
    else:
        draw_disk({pos:portal.pos, z:portal.z, radius:portal.radius, color: #0000, outline:#248})

let explosions = []
let buildings = []
let missiles = []
let portals = []
let current_portal = nil
let cursor_pos = 50% SCREEN_SIZE

enter
────────────────────────────────────────────────────────────────────────
explosions = []
buildings = []
missiles = []
portals = []
current_portal = nil
cursor_pos = 50% SCREEN_SIZE

// create building entities
for x in [64, 128, 192, 256, 320]:
    push(buildings, make_building(xy(x, GROUND_Y-4)))

frame
────────────────────────────────────────────────────────────────────────

// handle input
cursor_pos.x = clamp(cursor_pos.x + joy.x, 0, SCREEN_SIZE.x-1)
cursor_pos.y = clamp(cursor_pos.y + joy.y, 0, SCREEN_SIZE.y-1)
if joy.aa:
    //push(explosions, make_explosion(cursor_pos))
    let portal = make_portal(cursor_pos)
    if current_portal == ∅: // first in pair
        current_portal = portal
    else: // second in pair
        portal.buddy = current_portal
        current_portal.buddy = portal
        // Trace from all missiles to new portals, to see if they're closer
        const new_portals = [current_portal, portal]
        for m in missiles:
            const len = if m.next_portal ≠ ∅ then magnitude(m.portal_entry_point - m.pos) else infinity
            let ray = {pos:m.pos, dir:m.dir, length: len}
            const hit_portal = ray_intersect(ray, new_portals)
            if hit_portal ≠ ∅:
                m.next_portal = hit_portal
                m.portal_entry_point = ray.pos + ray.dir*ray.length
                m.portal_exit_point = missile_portal_exit_point(m.dir, hit_portal, m.portal_entry_point)
        // add both portals to the master list
        push(portals, current_portal, portal)
        current_portal = ∅

// randomly spawn a new missile
if ξ < 0.003:
    todo("trace from new missile to all portals")
    push(missiles, make_missile())
// Grow/prune explosions
iterate(explosions, itor_explosion_update)
// Advance missiles & check for impact
iterate(missiles, itor_missile_update)
// Destroy any buildings that were hit by missiles
iterate(buildings, itor_building_destroy)

// Rendering
// cursor
draw_line({A:cursor_pos-xy(3,0), B:cursor_pos+xy(3,0), z:10, color:#f})
draw_line({A:cursor_pos-xy(0,3), B:cursor_pos+xy(0,3), z:10, color:#f})
// ground
draw_corner_rect({corner:xy(0,GROUND_Y), size:xy(SCREEN_SIZE.x, 16), z:0, color:#242})
// buildings
for building in buildings:
    draw_entity(building)
// explosions
iterate(explosions, itor_explosion_draw)
// missiles
iterate(missiles, itor_missile_draw)
// portals
iterate(portals, itor_portal_draw)
if current_portal ≠ ∅:
    itor_portal_draw(current_portal)
